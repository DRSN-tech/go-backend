// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package generated

import (
	domain "github.com/DRSN-tech/go-backend/internal/domain"
	converter "github.com/DRSN-tech/go-backend/internal/repository/pgdb/converter"
	usecase "github.com/DRSN-tech/go-backend/internal/usecase"
	uuid "github.com/google/uuid"
)

type CategoryConverterImpl struct{}

func (c *CategoryConverterImpl) ToEntity(source *converter.CategoryModel) *domain.Category {
	var pDomainCategory *domain.Category
	if source != nil {
		var domainCategory domain.Category
		domainCategory.ID = (*source).ID
		domainCategory.Name = (*source).Name
		domainCategory.CreatedAt = converter.ConvertTime((*source).CreatedAt)
		domainCategory.UpdatedAt = converter.ConvertPointerTime((*source).UpdatedAt)
		domainCategory.IsArchived = (*source).IsArchived
		pDomainCategory = &domainCategory
	}
	return pDomainCategory
}
func (c *CategoryConverterImpl) ToModel(source *domain.Category) *converter.CategoryModel {
	var pConverterCategoryModel *converter.CategoryModel
	if source != nil {
		var converterCategoryModel converter.CategoryModel
		converterCategoryModel.ID = (*source).ID
		converterCategoryModel.Name = (*source).Name
		converterCategoryModel.CreatedAt = converter.ConvertTime((*source).CreatedAt)
		converterCategoryModel.UpdatedAt = converter.ConvertPointerTime((*source).UpdatedAt)
		converterCategoryModel.IsArchived = (*source).IsArchived
		pConverterCategoryModel = &converterCategoryModel
	}
	return pConverterCategoryModel
}

type OutboxEventConverterImpl struct{}

func (c *OutboxEventConverterImpl) ToArrEntity(source []*converter.OutboxEventModel) []*usecase.OutboxEvent {
	var pUsecaseOutboxEventList []*usecase.OutboxEvent
	if source != nil {
		pUsecaseOutboxEventList = make([]*usecase.OutboxEvent, len(source))
		for i := 0; i < len(source); i++ {
			pUsecaseOutboxEventList[i] = c.ToEntity(source[i])
		}
	}
	return pUsecaseOutboxEventList
}
func (c *OutboxEventConverterImpl) ToEntity(source *converter.OutboxEventModel) *usecase.OutboxEvent {
	var pUsecaseOutboxEvent *usecase.OutboxEvent
	if source != nil {
		var usecaseOutboxEvent usecase.OutboxEvent
		usecaseOutboxEvent.ID = (*source).ID
		usecaseOutboxEvent.EventID = c.uuidUUIDToUuidUUID((*source).EventID)
		usecaseOutboxEvent.ProductID = (*source).ProductID
		usecaseOutboxEvent.EventType = converter.ConvertOutboxEventType((*source).EventType)
		if (*source).Payload != nil {
			usecaseOutboxEvent.Payload = make([]uint8, len((*source).Payload))
			for i := 0; i < len((*source).Payload); i++ {
				usecaseOutboxEvent.Payload[i] = (*source).Payload[i]
			}
		}
		usecaseOutboxEvent.Status = converter.ConvertOutBoxStatus((*source).Status)
		usecaseOutboxEvent.CreatedAt = converter.ConvertTime((*source).CreatedAt)
		usecaseOutboxEvent.ProcessingStartedAt = converter.ConvertPointerTime((*source).ProcessingStartedAt)
		usecaseOutboxEvent.ProcessedAt = converter.ConvertPointerTime((*source).ProcessedAt)
		pUsecaseOutboxEvent = &usecaseOutboxEvent
	}
	return pUsecaseOutboxEvent
}
func (c *OutboxEventConverterImpl) ToModel(source *usecase.OutboxEvent) *converter.OutboxEventModel {
	var pConverterOutboxEventModel *converter.OutboxEventModel
	if source != nil {
		var converterOutboxEventModel converter.OutboxEventModel
		converterOutboxEventModel.ID = (*source).ID
		converterOutboxEventModel.EventID = c.uuidUUIDToUuidUUID((*source).EventID)
		converterOutboxEventModel.ProductID = (*source).ProductID
		converterOutboxEventModel.EventType = converter.ConvertOutboxEventType((*source).EventType)
		if (*source).Payload != nil {
			converterOutboxEventModel.Payload = make([]uint8, len((*source).Payload))
			for i := 0; i < len((*source).Payload); i++ {
				converterOutboxEventModel.Payload[i] = (*source).Payload[i]
			}
		}
		converterOutboxEventModel.Status = converter.ConvertOutBoxStatus((*source).Status)
		converterOutboxEventModel.CreatedAt = converter.ConvertTime((*source).CreatedAt)
		converterOutboxEventModel.ProcessingStartedAt = converter.ConvertPointerTime((*source).ProcessingStartedAt)
		converterOutboxEventModel.ProcessedAt = converter.ConvertPointerTime((*source).ProcessedAt)
		pConverterOutboxEventModel = &converterOutboxEventModel
	}
	return pConverterOutboxEventModel
}
func (c *OutboxEventConverterImpl) uuidUUIDToUuidUUID(source uuid.UUID) uuid.UUID {
	var uuidUUID uuid.UUID
	for i := 0; i < len(source); i++ {
		uuidUUID[i] = source[i]
	}
	return uuidUUID
}

type ProductConverterImpl struct{}

func (c *ProductConverterImpl) ToEntity(source *converter.ProductModel) *domain.Product {
	var pDomainProduct *domain.Product
	if source != nil {
		var domainProduct domain.Product
		domainProduct.ID = (*source).ID
		domainProduct.Name = (*source).Name
		domainProduct.Price = (*source).Price
		domainProduct.CategoryID = (*source).CategoryID
		domainProduct.CreatedAt = converter.ConvertTime((*source).CreatedAt)
		domainProduct.UpdatedAt = converter.ConvertPointerTime((*source).UpdatedAt)
		domainProduct.IsArchived = (*source).IsArchived
		pDomainProduct = &domainProduct
	}
	return pDomainProduct
}
func (c *ProductConverterImpl) ToModel(source *domain.Product) *converter.ProductModel {
	var pConverterProductModel *converter.ProductModel
	if source != nil {
		var converterProductModel converter.ProductModel
		converterProductModel.ID = (*source).ID
		converterProductModel.Name = (*source).Name
		converterProductModel.Price = (*source).Price
		converterProductModel.CategoryID = (*source).CategoryID
		converterProductModel.CreatedAt = converter.ConvertTime((*source).CreatedAt)
		converterProductModel.UpdatedAt = converter.ConvertPointerTime((*source).UpdatedAt)
		converterProductModel.IsArchived = (*source).IsArchived
		pConverterProductModel = &converterProductModel
	}
	return pConverterProductModel
}
